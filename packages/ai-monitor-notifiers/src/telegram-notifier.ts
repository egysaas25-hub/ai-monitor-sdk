import type { IAlert, IDailyReport, IDeployment, INotifier, IPipelineStatus } from '@aker/ai-monitor-core';

/**
 * Telegram notifier configuration
 */
export interface ITelegramConfig {
  token: string;
  chatId: string;
  parseMode?: 'Markdown' | 'HTML';
  disableWebPagePreview?: boolean;
}

/**
 * Telegram notifier implementation
 * Sends notifications to Telegram via bot API
 */
export class TelegramNotifier implements INotifier {
  private bot: any;
  private chatId: string;
  private parseMode: 'Markdown' | 'HTML';
  private disableWebPagePreview: boolean;
  private enabled: boolean = false;

  constructor(config: ITelegramConfig) {
    this.chatId = config.chatId;
    this.parseMode = config.parseMode || 'Markdown';
    this.disableWebPagePreview = config.disableWebPagePreview ?? true;

    try {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const { Telegram } = require('telegram');
      this.bot = new Telegram(config.token);
      this.enabled = true;
    } catch (error) {
      console.error('Failed to initialize Telegram bot. Make sure "telegram" package is installed.');
      console.error('Install with: npm install telegram');
      this.enabled = false;
    }
  }

  async send(message: string): Promise<void> {
    if (!this.enabled) {
      console.warn('Telegram notifier disabled - skipping notification');
      return;
    }

    try {
      await this.bot.sendMessage(this.chatId, message, {
        parse_mode: this.parseMode,
        disable_web_page_preview: this.disableWebPagePreview,
      });
    } catch (error) {
      console.error('Failed to send Telegram notification:', error);
      throw error;
    }
  }

  async sendAlert(alert: IAlert): Promise<void> {
    if (!this.enabled) return;

    const emoji = this.getSeverityEmoji(alert.severity);
    const timestamp = alert.timestamp || new Date();

    const metricsStr = alert.metrics
      ? `\n\`metrics\`:\n\`\`\`\n${JSON.stringify(alert.metrics, null, 2).substring(0, 500)}\n\`\`\``
      : '';

    const message = `
${emoji} *${alert.severity}* - ${alert.title}

${alert.message}

*Time:* ${timestamp.toISOString()}${metricsStr}
    `.trim();

    await this.send(message);
  }

  async sendPipelineStatus(status: IPipelineStatus): Promise<void> {
    if (!this.enabled) return;

    const emoji = this.getStatusEmoji(status.status);

    const changesStr =
      status.changes && status.changes.length > 0
        ? `\n*Changes:*\n${status.changes.map((c) => `‚Ä¢ ${c}`).join('\n')}`
        : '';

    const durationStr = status.duration ? `\n*Duration:* ${this.formatDuration(status.duration)}` : '';

    const urlStr = status.url ? `\n[View Build](${status.url})` : '';

    const message = `
${emoji} *${status.jobName}* - Build #${status.buildNumber}

*Status:* ${status.status}${durationStr}${changesStr}${urlStr}
    `.trim();

    await this.send(message);
  }

  async sendDeploymentNotification(deployment: IDeployment): Promise<void> {
    if (!this.enabled) return;

    const emoji = deployment.status === 'SUCCESS' ? '‚úÖ' : '‚ùå';

    const changesStr =
      deployment.changes && deployment.changes.length > 0
        ? `\n*Changes:*\n${deployment.changes.map((c) => `‚Ä¢ ${c}`).join('\n')}`
        : '';

    const durationStr = deployment.duration ? `\n*Duration:* ${this.formatDuration(deployment.duration)}` : '';

    const urlStr = deployment.url ? `\n[View Environment](${deployment.url})` : '';

    const message = `
${emoji} *Deployment* - ${deployment.environment}

*Version:* ${deployment.version}
*Status:* ${deployment.status}${durationStr}${changesStr}${urlStr}
    `.trim();

    await this.send(message);
  }

  async sendDailyReport(report: IDailyReport): Promise<void> {
    if (!this.enabled) return;

    const message = `
üìä *Daily Health Report* - ${report.date.toLocaleDateString()}

*Overall Status:* ${report.totalAlerts === 0 ? '‚úÖ Healthy' : '‚ö†Ô∏è Issues Found'}

üìà *Summary:*
‚Ä¢ Total Alerts: ${report.totalAlerts}
‚Ä¢ Critical: ${report.criticalAlerts}
‚Ä¢ Auto-Fixed: ${report.autoFixes}
‚Ä¢ Uptime: ${report.uptime}

${
  report.topIssues.length > 0
    ? `*Top Issues:*\n${report.topIssues.map((issue, i) => `${i + 1}. ${issue}`).join('\n')}`
    : ''
}

_Report generated by AI Monitor_
    `.trim();

    await this.send(message);
  }

  private getSeverityEmoji(severity: string): string {
    switch (severity) {
      case 'CRITICAL':
        return 'üö®';
      case 'WARNING':
        return '‚ö†Ô∏è';
      case 'INFO':
        return '‚ÑπÔ∏è';
      default:
        return 'üì¢';
    }
  }

  private getStatusEmoji(status: string): string {
    switch (status) {
      case 'SUCCESS':
        return '‚úÖ';
      case 'FAILURE':
        return '‚ùå';
      case 'ABORTED':
        return '‚èπÔ∏è';
      case 'UNSTABLE':
        return '‚ö†Ô∏è';
      default:
        return 'üìã';
    }
  }

  private formatDuration(seconds: number): string {
    if (seconds < 60) return `${seconds}s`;
    if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
    return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
  }
}
