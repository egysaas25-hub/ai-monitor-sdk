"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelegramNotifier = void 0;
const telegram_1 = require("telegram");
const config_1 = require("../config");
const logger_1 = require("../utils/logger");
class TelegramNotifier {
    constructor() {
        this.enabled = config_1.config.TELEGRAM_BOT_TOKEN !== undefined &&
            config_1.config.TELEGRAM_CHAT_ID !== undefined;
        if (this.enabled) {
            this.bot = new telegram_1.Telegram(config_1.config.TELEGRAM_BOT_TOKEN);
            this.chatId = config_1.config.TELEGRAM_CHAT_ID;
            logger_1.logger.info('Telegram notifier initialized');
        }
        else {
            logger_1.logger.warn('Telegram notifier disabled - missing credentials');
        }
    }
    async send(message) {
        if (!this.enabled) {
            logger_1.logger.warn('Telegram notifier disabled - skipping notification');
            return;
        }
        try {
            await this.bot.sendMessage(this.chatId, message, {
                parse_mode: 'Markdown',
                disable_web_page_preview: true
            });
            logger_1.logger.info('Telegram notification sent');
        }
        catch (error) {
            logger_1.logger.error('Failed to send Telegram notification:', error);
            throw error;
        }
    }
    async sendAlert(alert) {
        if (!this.enabled)
            return;
        const emoji = this.getSeverityEmoji(alert.severity);
        const timestamp = alert.timestamp || new Date();
        const formattedMessage = this.formatAlertMessage({
            emoji,
            severity: alert.severity,
            title: alert.title,
            message: alert.message,
            metrics: alert.metrics,
            timestamp
        });
        await this.send(formattedMessage);
    }
    async sendPipelineStatus(status) {
        if (!this.enabled)
            return;
        const emoji = this.getStatusEmoji(status.status);
        const message = this.formatPipelineMessage({
            emoji,
            ...status
        });
        await this.send(message);
    }
    async sendDeploymentNotification(deployment) {
        if (!this.enabled)
            return;
        const emoji = deployment.status === 'SUCCESS' ? 'âœ…' : 'âŒ';
        const message = this.formatDeploymentMessage({
            emoji,
            ...deployment
        });
        await this.send(message);
    }
    async sendDailyReport(report) {
        if (!this.enabled)
            return;
        const message = this.formatDailyReport(report);
        await this.send(message);
    }
    formatAlertMessage(alert) {
        const metricsStr = alert.metrics
            ? `\n\`metrics\`:\n\`\`\`\n${JSON.stringify(alert.metrics, null, 2).substring(0, 500)}\n\`\`\``
            : '';
        return `
${alert.emoji} *${alert.severity}* - ${alert.title}

${alert.message}

*Time:* ${alert.timestamp.toISOString()}${metricsStr}
    `.trim();
    }
    formatPipelineMessage(status) {
        const changesStr = status.changes && status.changes.length > 0
            ? `\n*Changes:*\n${status.changes.map(c => `â€¢ ${c}`).join('\n')}`
            : '';
        const durationStr = status.duration
            ? `\n*Duration:* ${this.formatDuration(status.duration)}`
            : '';
        const urlStr = status.url
            ? `\n[View Build](${status.url})`
            : '';
        return `
${status.emoji} *${status.jobName}* - Build #${status.buildNumber}

*Status:* ${status.status}${durationStr}${changesStr}${urlStr}
    `.trim();
    }
    formatDeploymentMessage(deployment) {
        const changesStr = deployment.changes && deployment.changes.length > 0
            ? `\n*Changes:*\n${deployment.changes.map(c => `â€¢ ${c}`).join('\n')}`
            : '';
        const durationStr = deployment.duration
            ? `\n*Duration:* ${this.formatDuration(deployment.duration)}`
            : '';
        const urlStr = deployment.url
            ? `\n[View Environment](${deployment.url})`
            : '';
        return `
${deployment.emoji} *Deployment* - ${deployment.environment}

*Version:* ${deployment.version}
*Status:* ${deployment.status}${durationStr}${changesStr}${urlStr}
    `.trim();
    }
    formatDailyReport(report) {
        return `
ğŸ“Š *Daily Health Report* - ${report.date.toLocaleDateString()}

*Overall Status:* ${report.totalAlerts === 0 ? 'âœ… Healthy' : 'âš ï¸ Issues Found'}

ğŸ“ˆ *Summary:*
â€¢ Total Alerts: ${report.totalAlerts}
â€¢ Critical: ${report.criticalAlerts}
â€¢ Auto-Fixed: ${report.autoFixes}
â€¢ Uptime: ${report.uptime}

${report.topIssues.length > 0 ? `*Top Issues:*\n${report.topIssues.map((issue, i) => `${i + 1}. ${issue}`).join('\n')}` : ''}

_Report generated by FitCoach AI Monitor_
    `.trim();
    }
    getSeverityEmoji(severity) {
        switch (severity) {
            case 'CRITICAL': return 'ğŸš¨';
            case 'WARNING': return 'âš ï¸';
            case 'INFO': return 'â„¹ï¸';
            default: return 'ğŸ“¢';
        }
    }
    getStatusEmoji(status) {
        switch (status) {
            case 'SUCCESS': return 'âœ…';
            case 'FAILURE': return 'âŒ';
            case 'ABORTED': return 'â¹ï¸';
            case 'UNSTABLE': return 'âš ï¸';
            default: return 'ğŸ“‹';
        }
    }
    formatDuration(seconds) {
        if (seconds < 60)
            return `${seconds}s`;
        if (seconds < 3600)
            return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
        return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
    }
}
exports.TelegramNotifier = TelegramNotifier;
//# sourceMappingURL=telegram-notifier.js.map